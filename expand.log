#![feature(prelude_import)]
#![allow(warnings)]
//! # Crest
//!
//! Crest is [Peacock](#)'s core library for parsing css files.
//! While Crest is intended for use by Peacock, it is designed
//! to be usable for other projects as well.
//!
//! For more information on Peacock, [click here](#)!
//!
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod parse {
    use pest_consume::{Error, Parser, match_nodes};
    use std::collections::HashMap;
    use crate::values;
    pub type Result<T> = std::result::Result<T, Error<Rule>>;
    type Node<'i> = pest_consume::Node<'i, Rule, ()>;
    #[grammar = "css.pest"]
    pub struct CssParser;
    #[allow(non_upper_case_globals)]
    const _PEST_GRAMMAR_CssParser: [&'static str; 1usize] = [
        "\nCss = { SOI ~ Rule* ~ EOI }\n\nRule = { Selector ~ \"{\" ~ PropertyList ~ \"}\" }\n\nSelector = { CompoundSelector }\n    CompoundSelector = { ComplexSelector ~ (\",\" ~ ComplexSelector)* }\n    ComplexSelector = { SimpleSelector ~ (Combinator ~ SimpleSelector)* }\n        Combinator = @{ NextSibling | Child | Column | SubsequentSibling | Descendent | Namespace }\n            NextSibling         = { \"+\" }\n            Child               = { \">\" }\n            Column              = { \"||\" }\n            SubsequentSibling   = { \"~\" }\n            Namespace           = { \"|\" }\n            Descendent          = @{ \" \" }\n    // TODO: Implement { Attribute, Pseudoclass, Pseudoelement } Simple Selectors\n    SimpleSelector = { (BasicSelector)* }\n        BasicSelector = { TypeSelector | ClassSelector | IdSelector | UniversalSelector }\n            IdSelector = { \"#\" ~ !(\"#\") ~ BasicSelector }\n            ClassSelector = { \".\" ~ !(\".\") ~ BasicSelector }\n            TypeSelector = { Identifier }\n            UniversalSelector = { \"*\" }\n\nPropertyList = { Property* }\nProperty = { Identifier ~ \":\" ~ ValueList ~ \";\" }\n\nValueList = { (Value ~ (\",\" ~ Value)*)+ }\nValue = { Function | Number | Identifier | String | Hex }\n    Function = { Identifier ~ \"(\" ~ ValueList ~ \")\" }\n    Hex = @{ \"#\" ~ (ASCII_DIGIT | \'a\'..\'f\' | \'A\'..\'F\'){6} }\n    String = { (\"\\\"\" ~ (!(\"\\\"\") ~ ASCII)* ~ \"\\\"\") | (\"\'\" ~ (!(\"\'\") ~ ASCII)* ~ \"\'\") }\n    Number = { ( (\"+\"|\"-\")? ~ (Float | Int) ~ Unit)\n             | ( (\"+\"|\"-\")? ~ (Float | Int)) }\n        Int = { ASCII_DIGIT+ }\n        Float = { ASCII_DIGIT+ ~ \".\" ~ ASCII_DIGIT+ }\n        Unit = { (\"cm\"|\"mm\"|\"in\"|\"px\"|\"pt\"|\"pc\") | (\"em\"|\"ex\"|\"ch\"|\"rem\"|\"vw\"|\"vh\"|\"vmin\"|\"vmax\"|\"%\") }\n\nIdentifier = { (ASCII_ALPHA|\"_\"|\"-\") ~ (ASCII_ALPHANUMERIC|\"_\"|\"-\")* }\n\nWHITESPACE = _{ (\" \" | \"\\t\" | NEWLINE) }\nCOMMENT = _{ \"/*\" ~ (!\"*/\" ~ ANY)* ~ \"*/\" }\n",
    ];
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    pub enum Rule {
        ///End-of-input
        EOI,
        Css,
        Rule,
        Selector,
        CompoundSelector,
        ComplexSelector,
        Combinator,
        NextSibling,
        Child,
        Column,
        SubsequentSibling,
        Namespace,
        Descendent,
        SimpleSelector,
        BasicSelector,
        IdSelector,
        ClassSelector,
        TypeSelector,
        UniversalSelector,
        PropertyList,
        Property,
        ValueList,
        Value,
        Function,
        Hex,
        String,
        Number,
        Int,
        Float,
        Unit,
        Identifier,
        WHITESPACE,
        COMMENT,
    }
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::clone::Clone for Rule {
        #[inline]
        fn clone(&self) -> Rule {
            *self
        }
    }
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::marker::Copy for Rule {}
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::fmt::Debug for Rule {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Rule::EOI => "EOI",
                    Rule::Css => "Css",
                    Rule::Rule => "Rule",
                    Rule::Selector => "Selector",
                    Rule::CompoundSelector => "CompoundSelector",
                    Rule::ComplexSelector => "ComplexSelector",
                    Rule::Combinator => "Combinator",
                    Rule::NextSibling => "NextSibling",
                    Rule::Child => "Child",
                    Rule::Column => "Column",
                    Rule::SubsequentSibling => "SubsequentSibling",
                    Rule::Namespace => "Namespace",
                    Rule::Descendent => "Descendent",
                    Rule::SimpleSelector => "SimpleSelector",
                    Rule::BasicSelector => "BasicSelector",
                    Rule::IdSelector => "IdSelector",
                    Rule::ClassSelector => "ClassSelector",
                    Rule::TypeSelector => "TypeSelector",
                    Rule::UniversalSelector => "UniversalSelector",
                    Rule::PropertyList => "PropertyList",
                    Rule::Property => "Property",
                    Rule::ValueList => "ValueList",
                    Rule::Value => "Value",
                    Rule::Function => "Function",
                    Rule::Hex => "Hex",
                    Rule::String => "String",
                    Rule::Number => "Number",
                    Rule::Int => "Int",
                    Rule::Float => "Float",
                    Rule::Unit => "Unit",
                    Rule::Identifier => "Identifier",
                    Rule::WHITESPACE => "WHITESPACE",
                    Rule::COMMENT => "COMMENT",
                },
            )
        }
    }
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::cmp::Eq for Rule {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::hash::Hash for Rule {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::cmp::Ord for Rule {
        #[inline]
        fn cmp(&self, other: &Rule) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::marker::StructuralPartialEq for Rule {}
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::cmp::PartialEq for Rule {
        #[inline]
        fn eq(&self, other: &Rule) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    #[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
    impl ::core::cmp::PartialOrd for Rule {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Rule,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl Rule {
        pub fn all_rules() -> &'static [Rule] {
            &[
                Rule::Css,
                Rule::Rule,
                Rule::Selector,
                Rule::CompoundSelector,
                Rule::ComplexSelector,
                Rule::Combinator,
                Rule::NextSibling,
                Rule::Child,
                Rule::Column,
                Rule::SubsequentSibling,
                Rule::Namespace,
                Rule::Descendent,
                Rule::SimpleSelector,
                Rule::BasicSelector,
                Rule::IdSelector,
                Rule::ClassSelector,
                Rule::TypeSelector,
                Rule::UniversalSelector,
                Rule::PropertyList,
                Rule::Property,
                Rule::ValueList,
                Rule::Value,
                Rule::Function,
                Rule::Hex,
                Rule::String,
                Rule::Number,
                Rule::Int,
                Rule::Float,
                Rule::Unit,
                Rule::Identifier,
                Rule::WHITESPACE,
                Rule::COMMENT,
            ]
        }
    }
    #[allow(clippy::all)]
    impl ::pest::Parser<Rule> for CssParser {
        fn parse<'i>(
            rule: Rule,
            input: &'i str,
        ) -> ::std::result::Result<
            ::pest::iterators::Pairs<'i, Rule>,
            ::pest::error::Error<Rule>,
        > {
            mod rules {
                #![allow(clippy::upper_case_acronyms)]
                pub mod hidden {
                    use super::super::Rule;
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn skip(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        if state.atomicity() == ::pest::Atomicity::NonAtomic {
                            state
                                .sequence(|state| {
                                    state
                                        .repeat(|state| super::visible::WHITESPACE(state))
                                        .and_then(|state| {
                                            state
                                                .repeat(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            super::visible::COMMENT(state)
                                                                .and_then(|state| {
                                                                    state.repeat(|state| super::visible::WHITESPACE(state))
                                                                })
                                                        })
                                                })
                                        })
                                })
                        } else {
                            Ok(state)
                        }
                    }
                }
                pub mod visible {
                    use super::super::Rule;
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Css(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Css,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::SOI(state)
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    self::Rule(state)
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| { self::Rule(state) })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { self::EOI(state) })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Rule(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Rule,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::Selector(state)
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string("{") })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { self::PropertyList(state) })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string("}") })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Selector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Selector,
                                |state| { self::CompoundSelector(state) },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn CompoundSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::CompoundSelector,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::ComplexSelector(state)
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    state
                                                                        .sequence(|state| {
                                                                            state
                                                                                .match_string(",")
                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                .and_then(|state| { self::ComplexSelector(state) })
                                                                        })
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| {
                                                                                                    state
                                                                                                        .sequence(|state| {
                                                                                                            state
                                                                                                                .match_string(",")
                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                .and_then(|state| { self::ComplexSelector(state) })
                                                                                                        })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn ComplexSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::ComplexSelector,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::SimpleSelector(state)
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    state
                                                                        .sequence(|state| {
                                                                            self::Combinator(state)
                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                .and_then(|state| { self::SimpleSelector(state) })
                                                                        })
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| {
                                                                                                    state
                                                                                                        .sequence(|state| {
                                                                                                            self::Combinator(state)
                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                .and_then(|state| { self::SimpleSelector(state) })
                                                                                                        })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Combinator(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Combinator,
                                |state| {
                                    state
                                        .atomic(
                                            ::pest::Atomicity::Atomic,
                                            |state| {
                                                self::NextSibling(state)
                                                    .or_else(|state| { self::Child(state) })
                                                    .or_else(|state| { self::Column(state) })
                                                    .or_else(|state| { self::SubsequentSibling(state) })
                                                    .or_else(|state| { self::Descendent(state) })
                                                    .or_else(|state| { self::Namespace(state) })
                                            },
                                        )
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn NextSibling(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(Rule::NextSibling, |state| { state.match_string("+") })
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Child(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.rule(Rule::Child, |state| { state.match_string(">") })
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Column(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.rule(Rule::Column, |state| { state.match_string("||") })
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn SubsequentSibling(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::SubsequentSibling,
                                |state| { state.match_string("~") },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Namespace(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.rule(Rule::Namespace, |state| { state.match_string("|") })
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Descendent(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Descendent,
                                |state| {
                                    state
                                        .atomic(
                                            ::pest::Atomicity::Atomic,
                                            |state| { state.match_string(" ") },
                                        )
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn SimpleSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::SimpleSelector,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .optional(|state| {
                                                    self::BasicSelector(state)
                                                        .and_then(|state| {
                                                            state
                                                                .repeat(|state| {
                                                                    state
                                                                        .sequence(|state| {
                                                                            super::hidden::skip(state)
                                                                                .and_then(|state| { self::BasicSelector(state) })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn BasicSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::BasicSelector,
                                |state| {
                                    self::TypeSelector(state)
                                        .or_else(|state| { self::ClassSelector(state) })
                                        .or_else(|state| { self::IdSelector(state) })
                                        .or_else(|state| { self::UniversalSelector(state) })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn IdSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::IdSelector,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .match_string("#")
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state.lookahead(false, |state| { state.match_string("#") })
                                                })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { self::BasicSelector(state) })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn ClassSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::ClassSelector,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .match_string(".")
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state.lookahead(false, |state| { state.match_string(".") })
                                                })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { self::BasicSelector(state) })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn TypeSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::TypeSelector,
                                |state| { self::Identifier(state) },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn UniversalSelector(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::UniversalSelector,
                                |state| { state.match_string("*") },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn PropertyList(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::PropertyList,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .optional(|state| {
                                                    self::Property(state)
                                                        .and_then(|state| {
                                                            state
                                                                .repeat(|state| {
                                                                    state
                                                                        .sequence(|state| {
                                                                            super::hidden::skip(state)
                                                                                .and_then(|state| { self::Property(state) })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Property(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Property,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::Identifier(state)
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string(":") })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { self::ValueList(state) })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string(";") })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn ValueList(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::ValueList,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .sequence(|state| {
                                                    self::Value(state)
                                                        .and_then(|state| { super::hidden::skip(state) })
                                                        .and_then(|state| {
                                                            state
                                                                .sequence(|state| {
                                                                    state
                                                                        .optional(|state| {
                                                                            state
                                                                                .sequence(|state| {
                                                                                    state
                                                                                        .match_string(",")
                                                                                        .and_then(|state| { super::hidden::skip(state) })
                                                                                        .and_then(|state| { self::Value(state) })
                                                                                })
                                                                                .and_then(|state| {
                                                                                    state
                                                                                        .repeat(|state| {
                                                                                            state
                                                                                                .sequence(|state| {
                                                                                                    super::hidden::skip(state)
                                                                                                        .and_then(|state| {
                                                                                                            state
                                                                                                                .sequence(|state| {
                                                                                                                    state
                                                                                                                        .match_string(",")
                                                                                                                        .and_then(|state| { super::hidden::skip(state) })
                                                                                                                        .and_then(|state| { self::Value(state) })
                                                                                                                })
                                                                                                        })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    state
                                                                        .sequence(|state| {
                                                                            self::Value(state)
                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                .and_then(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            state
                                                                                                .optional(|state| {
                                                                                                    state
                                                                                                        .sequence(|state| {
                                                                                                            state
                                                                                                                .match_string(",")
                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                .and_then(|state| { self::Value(state) })
                                                                                                        })
                                                                                                        .and_then(|state| {
                                                                                                            state
                                                                                                                .repeat(|state| {
                                                                                                                    state
                                                                                                                        .sequence(|state| {
                                                                                                                            super::hidden::skip(state)
                                                                                                                                .and_then(|state| {
                                                                                                                                    state
                                                                                                                                        .sequence(|state| {
                                                                                                                                            state
                                                                                                                                                .match_string(",")
                                                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                                                .and_then(|state| { self::Value(state) })
                                                                                                                                        })
                                                                                                                                })
                                                                                                                        })
                                                                                                                })
                                                                                                        })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| {
                                                                                                    state
                                                                                                        .sequence(|state| {
                                                                                                            self::Value(state)
                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                .and_then(|state| {
                                                                                                                    state
                                                                                                                        .sequence(|state| {
                                                                                                                            state
                                                                                                                                .optional(|state| {
                                                                                                                                    state
                                                                                                                                        .sequence(|state| {
                                                                                                                                            state
                                                                                                                                                .match_string(",")
                                                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                                                .and_then(|state| { self::Value(state) })
                                                                                                                                        })
                                                                                                                                        .and_then(|state| {
                                                                                                                                            state
                                                                                                                                                .repeat(|state| {
                                                                                                                                                    state
                                                                                                                                                        .sequence(|state| {
                                                                                                                                                            super::hidden::skip(state)
                                                                                                                                                                .and_then(|state| {
                                                                                                                                                                    state
                                                                                                                                                                        .sequence(|state| {
                                                                                                                                                                            state
                                                                                                                                                                                .match_string(",")
                                                                                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                                                                                .and_then(|state| { self::Value(state) })
                                                                                                                                                                        })
                                                                                                                                                                })
                                                                                                                                                        })
                                                                                                                                                })
                                                                                                                                        })
                                                                                                                                })
                                                                                                                        })
                                                                                                                })
                                                                                                        })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Value(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Value,
                                |state| {
                                    self::Function(state)
                                        .or_else(|state| { self::Number(state) })
                                        .or_else(|state| { self::Identifier(state) })
                                        .or_else(|state| { self::String(state) })
                                        .or_else(|state| { self::Hex(state) })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Function(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Function,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::Identifier(state)
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string("(") })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { self::ValueList(state) })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string(")") })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Hex(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Hex,
                                |state| {
                                    state
                                        .atomic(
                                            ::pest::Atomicity::Atomic,
                                            |state| {
                                                state
                                                    .sequence(|state| {
                                                        state
                                                            .match_string("#")
                                                            .and_then(|state| {
                                                                self::ASCII_DIGIT(state)
                                                                    .or_else(|state| { state.match_range('a'..'f') })
                                                                    .or_else(|state| { state.match_range('A'..'F') })
                                                            })
                                                            .and_then(|state| {
                                                                self::ASCII_DIGIT(state)
                                                                    .or_else(|state| { state.match_range('a'..'f') })
                                                                    .or_else(|state| { state.match_range('A'..'F') })
                                                            })
                                                            .and_then(|state| {
                                                                self::ASCII_DIGIT(state)
                                                                    .or_else(|state| { state.match_range('a'..'f') })
                                                                    .or_else(|state| { state.match_range('A'..'F') })
                                                            })
                                                            .and_then(|state| {
                                                                self::ASCII_DIGIT(state)
                                                                    .or_else(|state| { state.match_range('a'..'f') })
                                                                    .or_else(|state| { state.match_range('A'..'F') })
                                                            })
                                                            .and_then(|state| {
                                                                self::ASCII_DIGIT(state)
                                                                    .or_else(|state| { state.match_range('a'..'f') })
                                                                    .or_else(|state| { state.match_range('A'..'F') })
                                                            })
                                                            .and_then(|state| {
                                                                self::ASCII_DIGIT(state)
                                                                    .or_else(|state| { state.match_range('a'..'f') })
                                                                    .or_else(|state| { state.match_range('A'..'F') })
                                                            })
                                                    })
                                            },
                                        )
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn String(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::String,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .match_string("\"")
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    state
                                                                        .sequence(|state| {
                                                                            state
                                                                                .lookahead(false, |state| { state.match_string("\"") })
                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                .and_then(|state| { self::ASCII(state) })
                                                                        })
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| {
                                                                                                    state
                                                                                                        .sequence(|state| {
                                                                                                            state
                                                                                                                .lookahead(false, |state| { state.match_string("\"") })
                                                                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                                                                .and_then(|state| { self::ASCII(state) })
                                                                                                        })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string("\"") })
                                        })
                                        .or_else(|state| {
                                            state
                                                .sequence(|state| {
                                                    state
                                                        .match_string("'")
                                                        .and_then(|state| { super::hidden::skip(state) })
                                                        .and_then(|state| {
                                                            state
                                                                .sequence(|state| {
                                                                    state
                                                                        .optional(|state| {
                                                                            state
                                                                                .sequence(|state| {
                                                                                    state
                                                                                        .lookahead(false, |state| { state.match_string("'") })
                                                                                        .and_then(|state| { super::hidden::skip(state) })
                                                                                        .and_then(|state| { self::ASCII(state) })
                                                                                })
                                                                                .and_then(|state| {
                                                                                    state
                                                                                        .repeat(|state| {
                                                                                            state
                                                                                                .sequence(|state| {
                                                                                                    super::hidden::skip(state)
                                                                                                        .and_then(|state| {
                                                                                                            state
                                                                                                                .sequence(|state| {
                                                                                                                    state
                                                                                                                        .lookahead(false, |state| { state.match_string("'") })
                                                                                                                        .and_then(|state| { super::hidden::skip(state) })
                                                                                                                        .and_then(|state| { self::ASCII(state) })
                                                                                                                })
                                                                                                        })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                        .and_then(|state| { super::hidden::skip(state) })
                                                        .and_then(|state| { state.match_string("'") })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Number(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Number,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .optional(|state| {
                                                    state
                                                        .match_string("+")
                                                        .or_else(|state| { state.match_string("-") })
                                                })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            self::Float(state)
                                                                .or_else(|state| { self::Int(state) })
                                                                .and_then(|state| { super::hidden::skip(state) })
                                                                .and_then(|state| { self::Unit(state) })
                                                        })
                                                        .or_else(|state| { self::Float(state) })
                                                        .or_else(|state| { self::Int(state) })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Int(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Int,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::ASCII_DIGIT(state)
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    self::ASCII_DIGIT(state)
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| { self::ASCII_DIGIT(state) })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Float(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Float,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .sequence(|state| {
                                                    self::ASCII_DIGIT(state)
                                                        .and_then(|state| { super::hidden::skip(state) })
                                                        .and_then(|state| {
                                                            state
                                                                .sequence(|state| {
                                                                    state
                                                                        .optional(|state| {
                                                                            self::ASCII_DIGIT(state)
                                                                                .and_then(|state| {
                                                                                    state
                                                                                        .repeat(|state| {
                                                                                            state
                                                                                                .sequence(|state| {
                                                                                                    super::hidden::skip(state)
                                                                                                        .and_then(|state| { self::ASCII_DIGIT(state) })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { state.match_string(".") })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| { self::ASCII_DIGIT(state) })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    self::ASCII_DIGIT(state)
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| { self::ASCII_DIGIT(state) })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Unit(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Unit,
                                |state| {
                                    state
                                        .match_string("cm")
                                        .or_else(|state| { state.match_string("mm") })
                                        .or_else(|state| { state.match_string("in") })
                                        .or_else(|state| { state.match_string("px") })
                                        .or_else(|state| { state.match_string("pt") })
                                        .or_else(|state| { state.match_string("pc") })
                                        .or_else(|state| { state.match_string("em") })
                                        .or_else(|state| { state.match_string("ex") })
                                        .or_else(|state| { state.match_string("ch") })
                                        .or_else(|state| { state.match_string("rem") })
                                        .or_else(|state| { state.match_string("vw") })
                                        .or_else(|state| { state.match_string("vh") })
                                        .or_else(|state| { state.match_string("vmin") })
                                        .or_else(|state| { state.match_string("vmax") })
                                        .or_else(|state| { state.match_string("%") })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn Identifier(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .rule(
                                Rule::Identifier,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            self::ASCII_ALPHA(state)
                                                .or_else(|state| { state.match_string("_") })
                                                .or_else(|state| { state.match_string("-") })
                                                .and_then(|state| { super::hidden::skip(state) })
                                                .and_then(|state| {
                                                    state
                                                        .sequence(|state| {
                                                            state
                                                                .optional(|state| {
                                                                    self::ASCII_ALPHANUMERIC(state)
                                                                        .or_else(|state| { state.match_string("_") })
                                                                        .or_else(|state| { state.match_string("-") })
                                                                        .and_then(|state| {
                                                                            state
                                                                                .repeat(|state| {
                                                                                    state
                                                                                        .sequence(|state| {
                                                                                            super::hidden::skip(state)
                                                                                                .and_then(|state| {
                                                                                                    self::ASCII_ALPHANUMERIC(state)
                                                                                                        .or_else(|state| { state.match_string("_") })
                                                                                                        .or_else(|state| { state.match_string("-") })
                                                                                                })
                                                                                        })
                                                                                })
                                                                        })
                                                                })
                                                        })
                                                })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn WHITESPACE(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .atomic(
                                ::pest::Atomicity::Atomic,
                                |state| {
                                    state
                                        .match_string(" ")
                                        .or_else(|state| { state.match_string("\t") })
                                        .or_else(|state| { self::NEWLINE(state) })
                                },
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case, unused_variables)]
                    pub fn COMMENT(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .atomic(
                                ::pest::Atomicity::Atomic,
                                |state| {
                                    state
                                        .sequence(|state| {
                                            state
                                                .match_string("/*")
                                                .and_then(|state| {
                                                    state
                                                        .repeat(|state| {
                                                            state
                                                                .sequence(|state| {
                                                                    state
                                                                        .lookahead(false, |state| { state.match_string("*/") })
                                                                        .and_then(|state| { self::ANY(state) })
                                                                })
                                                        })
                                                })
                                                .and_then(|state| { state.match_string("*/") })
                                        })
                                },
                            )
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn ANY(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.skip(1)
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn EOI(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.rule(Rule::EOI, |state| state.end_of_input())
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn SOI(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.start_of_input()
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn ASCII_DIGIT(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.match_range('0'..'9')
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn ASCII_ALPHA(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .match_range('a'..'z')
                            .or_else(|state| state.match_range('A'..'Z'))
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn ASCII_ALPHANUMERIC(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .match_range('a'..'z')
                            .or_else(|state| state.match_range('A'..'Z'))
                            .or_else(|state| state.match_range('0'..'9'))
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn ASCII(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state.match_range('\x00'..'\x7f')
                    }
                    #[inline]
                    #[allow(dead_code, non_snake_case, unused_variables)]
                    pub fn NEWLINE(
                        state: ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    ) -> ::pest::ParseResult<
                        ::std::boxed::Box<::pest::ParserState<'_, Rule>>,
                    > {
                        state
                            .match_string("\n")
                            .or_else(|state| state.match_string("\r\n"))
                            .or_else(|state| state.match_string("\r"))
                    }
                }
                pub use self::visible::*;
            }
            ::pest::state(
                input,
                |state| {
                    match rule {
                        Rule::Css => rules::Css(state),
                        Rule::Rule => rules::Rule(state),
                        Rule::Selector => rules::Selector(state),
                        Rule::CompoundSelector => rules::CompoundSelector(state),
                        Rule::ComplexSelector => rules::ComplexSelector(state),
                        Rule::Combinator => rules::Combinator(state),
                        Rule::NextSibling => rules::NextSibling(state),
                        Rule::Child => rules::Child(state),
                        Rule::Column => rules::Column(state),
                        Rule::SubsequentSibling => rules::SubsequentSibling(state),
                        Rule::Namespace => rules::Namespace(state),
                        Rule::Descendent => rules::Descendent(state),
                        Rule::SimpleSelector => rules::SimpleSelector(state),
                        Rule::BasicSelector => rules::BasicSelector(state),
                        Rule::IdSelector => rules::IdSelector(state),
                        Rule::ClassSelector => rules::ClassSelector(state),
                        Rule::TypeSelector => rules::TypeSelector(state),
                        Rule::UniversalSelector => rules::UniversalSelector(state),
                        Rule::PropertyList => rules::PropertyList(state),
                        Rule::Property => rules::Property(state),
                        Rule::ValueList => rules::ValueList(state),
                        Rule::Value => rules::Value(state),
                        Rule::Function => rules::Function(state),
                        Rule::Hex => rules::Hex(state),
                        Rule::String => rules::String(state),
                        Rule::Number => rules::Number(state),
                        Rule::Int => rules::Int(state),
                        Rule::Float => rules::Float(state),
                        Rule::Unit => rules::Unit(state),
                        Rule::Identifier => rules::Identifier(state),
                        Rule::WHITESPACE => rules::WHITESPACE(state),
                        Rule::COMMENT => rules::COMMENT(state),
                        Rule::EOI => rules::EOI(state),
                    }
                },
            )
        }
    }
    #[allow(non_camel_case_types)]
    pub enum AliasedRule {
        Value,
        EOI,
        Property,
        ValueList,
        PropertyList,
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for AliasedRule {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AliasedRule::Value => "Value",
                    AliasedRule::EOI => "EOI",
                    AliasedRule::Property => "Property",
                    AliasedRule::ValueList => "ValueList",
                    AliasedRule::PropertyList => "PropertyList",
                },
            )
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for AliasedRule {
        #[inline]
        fn clone(&self) -> AliasedRule {
            *self
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::Copy for AliasedRule {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for AliasedRule {}
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for AliasedRule {
        #[inline]
        fn eq(&self, other: &AliasedRule) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Eq for AliasedRule {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialOrd for AliasedRule {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AliasedRule,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::Ord for AliasedRule {
        #[inline]
        fn cmp(&self, other: &AliasedRule) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::hash::Hash for AliasedRule {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    impl ::pest_consume::Parser for CssParser {
        type Rule = Rule;
        type AliasedRule = AliasedRule;
        type Parser = Self;
        fn rule_alias(rule: Self::Rule) -> Self::AliasedRule {
            match rule {
                Rule::Value => Self::AliasedRule::Value,
                Rule::EOI => Self::AliasedRule::EOI,
                Rule::Property => Self::AliasedRule::Property,
                Rule::ValueList => Self::AliasedRule::ValueList,
                Rule::PropertyList => Self::AliasedRule::PropertyList,
                r => {
                    ::std::rt::panic_fmt(
                        format_args!(
                            "Rule `{0:?}` does not have a corresponding parsing method",
                            r,
                        ),
                    );
                }
            }
        }
        fn allows_shortcut(rule: Self::Rule) -> bool {
            match rule {
                Rule::Value => false,
                Rule::EOI => false,
                Rule::Property => false,
                Rule::ValueList => false,
                Rule::PropertyList => false,
                _ => false,
            }
        }
    }
    impl CssParser {
        #[allow(non_snake_case)]
        fn EOI(_input: Node) -> Result<()> {
            let mut _input = _input;
            while <Self as ::pest_consume::Parser>::allows_shortcut(_input.as_rule()) {
                if let ::std::result::Result::Ok(child) = _input.children().single() {
                    if child.as_aliased_rule::<Self>()
                        == <Self as ::pest_consume::Parser>::rule_alias(Rule::EOI)
                    {
                        _input = child;
                        continue;
                    }
                }
                break;
            }
            match _input.as_rule() {
                Rule::EOI => Ok(()),
                r => {
                    ::std::rt::panic_fmt(
                        format_args!(
                            "pest_consume::parser: called the `{0}` method on a node with rule `{1:?}`",
                            "EOI",
                            r,
                        ),
                    );
                }
            }
        }
        #[allow(non_snake_case)]
        fn PropertyList(input: Node) -> Result<HashMap<String, Vec<values::ValueType>>> {
            let mut input = input;
            while <Self as ::pest_consume::Parser>::allows_shortcut(input.as_rule()) {
                if let ::std::result::Result::Ok(child) = input.children().single() {
                    if child.as_aliased_rule::<Self>()
                        == <Self as ::pest_consume::Parser>::rule_alias(
                            Rule::PropertyList,
                        )
                    {
                        input = child;
                        continue;
                    }
                }
                break;
            }
            match input.as_rule() {
                Rule::PropertyList => {
                    let mut property_list: HashMap<String, Vec<values::ValueType>> = HashMap::new();
                    {
                        #[allow(unused_mut)]
                        let mut ___nodes = input.into_children();
                        let ___node_rules: ::std::vec::Vec<_> = ___nodes
                            .aliased_rules::<Self>()
                            .collect();
                        #[allow(unreachable_code, clippy::int_plus_one)]
                        match () {
                            _ if 0usize + 0usize <= ___node_rules.len()
                                && {
                                    let all_match = |slice: &[_]| {
                                        slice
                                            .iter()
                                            .all(|r| {
                                                *r
                                                    == <Self as ::pest_consume::Parser>::AliasedRule::Property
                                            })
                                    };
                                    all_match(
                                        &___node_rules[0usize..___node_rules.len() - 0usize],
                                    )
                                } && true => {
                                let properties = ___nodes
                                    .map(|n| Self::Property(n))
                                    .collect::<::std::result::Result<::std::vec::Vec<_>, _>>()?
                                    .into_iter();
                                {
                                    for (key, value_list) in properties {
                                        property_list.insert(key, value_list);
                                    }
                                }
                            }
                            _ => {
                                return ::std::result::Result::Err(
                                    ___nodes
                                        .error({
                                            let res = ::alloc::fmt::format(
                                                format_args!(
                                                    "Nodes didn\'t match any pattern: {0:?}",
                                                    ___node_rules,
                                                ),
                                            );
                                            res
                                        }),
                                );
                            }
                        }
                    };
                    Ok(property_list)
                }
                r => {
                    ::std::rt::panic_fmt(
                        format_args!(
                            "pest_consume::parser: called the `{0}` method on a node with rule `{1:?}`",
                            "PropertyList",
                            r,
                        ),
                    );
                }
            }
        }
        #[allow(non_snake_case)]
        fn Property(input: Node) -> Result<(String, Vec<values::ValueType>)> {
            let mut input = input;
            while <Self as ::pest_consume::Parser>::allows_shortcut(input.as_rule()) {
                if let ::std::result::Result::Ok(child) = input.children().single() {
                    if child.as_aliased_rule::<Self>()
                        == <Self as ::pest_consume::Parser>::rule_alias(Rule::Property)
                    {
                        input = child;
                        continue;
                    }
                }
                break;
            }
            match input.as_rule() {
                Rule::Property => {
                    #[allow(unused_mut)]
                    let mut ___nodes = input.into_children();
                    let ___node_rules: ::std::vec::Vec<_> = ___nodes
                        .aliased_rules::<Self>()
                        .collect();
                    #[allow(unreachable_code, clippy::int_plus_one)]
                    match () {
                        _ if 2usize + 0usize <= ___node_rules.len()
                            && ___node_rules[0usize]
                                == <Self as ::pest_consume::Parser>::AliasedRule::Identifier
                            && ___node_rules[1usize]
                                == <Self as ::pest_consume::Parser>::AliasedRule::ValueList
                            && 2usize + 0usize == ___node_rules.len() && true => {
                            let ident = Self::Identifier(___nodes.next().unwrap())?;
                            let values = Self::ValueList(___nodes.next().unwrap())?;
                            { Ok((ident, values)) }
                        }
                        _ => {
                            return ::std::result::Result::Err(
                                ___nodes
                                    .error({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Nodes didn\'t match any pattern: {0:?}",
                                                ___node_rules,
                                            ),
                                        );
                                        res
                                    }),
                            );
                        }
                    }
                }
                r => {
                    ::std::rt::panic_fmt(
                        format_args!(
                            "pest_consume::parser: called the `{0}` method on a node with rule `{1:?}`",
                            "Property",
                            r,
                        ),
                    );
                }
            }
        }
        #[allow(non_snake_case)]
        fn ValueList(input: Node) -> Result<Vec<values::ValueType>> {
            let mut input = input;
            while <Self as ::pest_consume::Parser>::allows_shortcut(input.as_rule()) {
                if let ::std::result::Result::Ok(child) = input.children().single() {
                    if child.as_aliased_rule::<Self>()
                        == <Self as ::pest_consume::Parser>::rule_alias(Rule::ValueList)
                    {
                        input = child;
                        continue;
                    }
                }
                break;
            }
            match input.as_rule() {
                Rule::ValueList => {
                    let mut value_list = Vec::new();
                    {
                        #[allow(unused_mut)]
                        let mut ___nodes = input.into_children();
                        let ___node_rules: ::std::vec::Vec<_> = ___nodes
                            .aliased_rules::<Self>()
                            .collect();
                        #[allow(unreachable_code, clippy::int_plus_one)]
                        match () {
                            _ if 0usize + 0usize <= ___node_rules.len()
                                && {
                                    let all_match = |slice: &[_]| {
                                        slice
                                            .iter()
                                            .all(|r| {
                                                *r == <Self as ::pest_consume::Parser>::AliasedRule::Value
                                            })
                                    };
                                    all_match(
                                        &___node_rules[0usize..___node_rules.len() - 0usize],
                                    )
                                } && true => {
                                let values = ___nodes
                                    .map(|n| Self::Value(n))
                                    .collect::<::std::result::Result<::std::vec::Vec<_>, _>>()?
                                    .into_iter();
                                {
                                    value_list.extend(values);
                                }
                            }
                            _ => {
                                return ::std::result::Result::Err(
                                    ___nodes
                                        .error({
                                            let res = ::alloc::fmt::format(
                                                format_args!(
                                                    "Nodes didn\'t match any pattern: {0:?}",
                                                    ___node_rules,
                                                ),
                                            );
                                            res
                                        }),
                                );
                            }
                        }
                    };
                    Ok(value_list)
                }
                r => {
                    ::std::rt::panic_fmt(
                        format_args!(
                            "pest_consume::parser: called the `{0}` method on a node with rule `{1:?}`",
                            "ValueList",
                            r,
                        ),
                    );
                }
            }
        }
        #[allow(non_snake_case)]
        fn Value(input: Node) -> Result<values::ValueType> {
            let mut input = input;
            while <Self as ::pest_consume::Parser>::allows_shortcut(input.as_rule()) {
                if let ::std::result::Result::Ok(child) = input.children().single() {
                    if child.as_aliased_rule::<Self>()
                        == <Self as ::pest_consume::Parser>::rule_alias(Rule::Value)
                    {
                        input = child;
                        continue;
                    }
                }
                break;
            }
            match input.as_rule() {
                Rule::Value => {
                    #[allow(unused_mut)]
                    let mut ___nodes = input.into_children();
                    let ___node_rules: ::std::vec::Vec<_> = ___nodes
                        .aliased_rules::<Self>()
                        .collect();
                    #[allow(unreachable_code, clippy::int_plus_one)]
                    match () {
                        _ if 1usize + 0usize <= ___node_rules.len()
                            && ___node_rules[0usize]
                                == <Self as ::pest_consume::Parser>::AliasedRule::Function
                            && 1usize + 0usize == ___node_rules.len() && true => {
                            let f = Self::Function(___nodes.next().unwrap())?;
                            Ok(values::ValueType::Function(f))
                        }
                        _ if 1usize + 0usize <= ___node_rules.len()
                            && ___node_rules[0usize]
                                == <Self as ::pest_consume::Parser>::AliasedRule::Number
                            && 1usize + 0usize == ___node_rules.len() && true => {
                            let n = Self::Number(___nodes.next().unwrap())?;
                            Ok(values::ValueType::Number(n))
                        }
                        _ if 1usize + 0usize <= ___node_rules.len()
                            && ___node_rules[0usize]
                                == <Self as ::pest_consume::Parser>::AliasedRule::Identifier
                            && 1usize + 0usize == ___node_rules.len() && true => {
                            let ident = Self::Identifier(___nodes.next().unwrap())?;
                            Ok(values::ValueType::Identifier(ident))
                        }
                        _ if 1usize + 0usize <= ___node_rules.len()
                            && ___node_rules[0usize]
                                == <Self as ::pest_consume::Parser>::AliasedRule::String
                            && 1usize + 0usize == ___node_rules.len() && true => {
                            let s = Self::String(___nodes.next().unwrap())?;
                            Ok(values::ValueType::String(s))
                        }
                        _ if 1usize + 0usize <= ___node_rules.len()
                            && ___node_rules[0usize]
                                == <Self as ::pest_consume::Parser>::AliasedRule::Hex
                            && 1usize + 0usize == ___node_rules.len() && true => {
                            let h = Self::Hex(___nodes.next().unwrap())?;
                            Ok(values::ValueType::Hex(h))
                        }
                        _ => {
                            return ::std::result::Result::Err(
                                ___nodes
                                    .error({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Nodes didn\'t match any pattern: {0:?}",
                                                ___node_rules,
                                            ),
                                        );
                                        res
                                    }),
                            );
                        }
                    }
                }
                r => {
                    ::std::rt::panic_fmt(
                        format_args!(
                            "pest_consume::parser: called the `{0}` method on a node with rule `{1:?}`",
                            "Value",
                            r,
                        ),
                    );
                }
            }
        }
    }
}
pub mod values {
    use pest::iterators::Pair;
    use super::parse::Rule;
    pub enum Error {
        ConversionError(String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Error {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Error::ConversionError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ConversionError",
                        &__self_0,
                    )
                }
            }
        }
    }
    pub enum Position {
        #[default]
        Static,
        Relative,
        Absolute,
    }
    #[automatically_derived]
    impl ::core::default::Default for Position {
        #[inline]
        fn default() -> Position {
            Self::Static
        }
    }
    pub enum DisplayOption {
        None,
        #[default]
        Block,
        Inline,
        Flow,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DisplayOption {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    DisplayOption::None => "None",
                    DisplayOption::Block => "Block",
                    DisplayOption::Inline => "Inline",
                    DisplayOption::Flow => "Flow",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for DisplayOption {
        #[inline]
        fn default() -> DisplayOption {
            Self::Block
        }
    }
    pub struct Display {
        pub outer: DisplayOption,
        pub inner: DisplayOption,
    }
    #[automatically_derived]
    impl ::core::default::Default for Display {
        #[inline]
        fn default() -> Display {
            Display {
                outer: ::core::default::Default::default(),
                inner: ::core::default::Default::default(),
            }
        }
    }
    pub enum Visibility {
        #[default]
        Visible,
        Hidden,
    }
    #[automatically_derived]
    impl ::core::default::Default for Visibility {
        #[inline]
        fn default() -> Visibility {
            Self::Visible
        }
    }
    pub enum Unit {
        Cm,
        Mm,
        In,
        Px,
        Pt,
        Pc,
        Em,
        Ex,
        Ch,
        Rem,
        VW,
        VH,
        VMin,
        VMax,
        Percent,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Unit {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Unit::Cm => "Cm",
                    Unit::Mm => "Mm",
                    Unit::In => "In",
                    Unit::Px => "Px",
                    Unit::Pt => "Pt",
                    Unit::Pc => "Pc",
                    Unit::Em => "Em",
                    Unit::Ex => "Ex",
                    Unit::Ch => "Ch",
                    Unit::Rem => "Rem",
                    Unit::VW => "VW",
                    Unit::VH => "VH",
                    Unit::VMin => "VMin",
                    Unit::VMax => "VMax",
                    Unit::Percent => "Percent",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Unit {
        #[inline]
        fn clone(&self) -> Unit {
            match self {
                Unit::Cm => Unit::Cm,
                Unit::Mm => Unit::Mm,
                Unit::In => Unit::In,
                Unit::Px => Unit::Px,
                Unit::Pt => Unit::Pt,
                Unit::Pc => Unit::Pc,
                Unit::Em => Unit::Em,
                Unit::Ex => Unit::Ex,
                Unit::Ch => Unit::Ch,
                Unit::Rem => Unit::Rem,
                Unit::VW => Unit::VW,
                Unit::VH => Unit::VH,
                Unit::VMin => Unit::VMin,
                Unit::VMax => Unit::VMax,
                Unit::Percent => Unit::Percent,
            }
        }
    }
    pub type Function = (String, Vec<ValueType>);
    pub type Number = (f32, Unit);
    pub type Color = [u8; 3];
    pub enum ValueType {
        Identifier(String),
        Number(Number),
        String(String),
        Color(Color),
        Function(Function),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ValueType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ValueType::Identifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Identifier",
                        &__self_0,
                    )
                }
                ValueType::Number(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Number",
                        &__self_0,
                    )
                }
                ValueType::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                ValueType::Color(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Color",
                        &__self_0,
                    )
                }
                ValueType::Function(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Function",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ValueType {
        #[inline]
        fn clone(&self) -> ValueType {
            match self {
                ValueType::Identifier(__self_0) => {
                    ValueType::Identifier(::core::clone::Clone::clone(__self_0))
                }
                ValueType::Number(__self_0) => {
                    ValueType::Number(::core::clone::Clone::clone(__self_0))
                }
                ValueType::String(__self_0) => {
                    ValueType::String(::core::clone::Clone::clone(__self_0))
                }
                ValueType::Color(__self_0) => {
                    ValueType::Color(::core::clone::Clone::clone(__self_0))
                }
                ValueType::Function(__self_0) => {
                    ValueType::Function(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    pub enum Combinator {
        None,
        NextSibling,
        Child,
        Column,
        SubsequentSibling,
        Namespace,
        Descendent,
    }
    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("{0:?}", self))
        }
    }
    impl std::error::Error for Error {}
    impl TryFrom<ValueType> for DisplayOption {
        type Error = Error;
        fn try_from(value: ValueType) -> Result<Self, Self::Error> {
            match value {
                ValueType::Identifier(display) => {
                    match display.as_str() {
                        "none" => Ok(DisplayOption::None),
                        "block" => Ok(DisplayOption::Block),
                        "inline" => Ok(DisplayOption::Inline),
                        "flow" => Ok(DisplayOption::Flow),
                        _ => {
                            Err(
                                Self::Error::ConversionError({
                                    let res = ::alloc::fmt::format(
                                        format_args!("invalid DisplayOption value: {0}", display),
                                    );
                                    res
                                }),
                            )
                        }
                    }
                }
                _ => {
                    Err(
                        Self::Error::ConversionError({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "unknown DisplayOption value type: {0:?}",
                                    value,
                                ),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    impl TryFrom<(ValueType, ValueType)> for Display {
        type Error = Error;
        fn try_from(value: (ValueType, ValueType)) -> Result<Self, Self::Error> {
            let inner_result = DisplayOption::try_from(value.0);
            let outer_result = DisplayOption::try_from(value.1);
            if inner_result.is_ok() && outer_result.is_ok() {
                Ok(Display {
                    inner: inner_result.unwrap(),
                    outer: outer_result.unwrap(),
                })
            } else if inner_result.is_err() {
                Err(inner_result.unwrap_err())
            } else {
                Err(outer_result.unwrap_err())
            }
        }
    }
    impl TryFrom<pest::iterators::Pair<'_, super::parse::Rule>> for ValueType {
        type Error = Error;
        fn try_from(value: Pair<'_, super::parse::Rule>) -> Result<Self, Self::Error> {
            if !match value.as_rule() {
                Rule::Value => true,
                _ => false,
            } {
                return Err(
                    Error::ConversionError({
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Cannot create a ValueType from \'{0}\'!",
                                value.clone().as_str(),
                            ),
                        );
                        res
                    }),
                );
            }
            ::core::panicking::panic("not yet implemented")
        }
    }
}
use pest::Parser as _;
use pest::iterators::Pair;
use parse::Rule;
pub enum Error {
    IncorrectRuleType(Rule, Rule),
    ValueError(values::Error),
}
#[automatically_derived]
impl ::core::fmt::Debug for Error {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            Error::IncorrectRuleType(__self_0, __self_1) => {
                ::core::fmt::Formatter::debug_tuple_field2_finish(
                    f,
                    "IncorrectRuleType",
                    __self_0,
                    &__self_1,
                )
            }
            Error::ValueError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ValueError",
                    &__self_0,
                )
            }
        }
    }
}
pub struct PropertyList(pub std::collections::HashMap<String, Vec<values::ValueType>>);
#[automatically_derived]
impl ::core::clone::Clone for PropertyList {
    #[inline]
    fn clone(&self) -> PropertyList {
        PropertyList(::core::clone::Clone::clone(&self.0))
    }
}
pub struct Selector {
    name: Option<String>,
    id: Option<String>,
    classes: Vec<String>,
    universal: bool,
}
pub struct RuleSet {
    pub selectors: std::rc::Rc<[Selector]>,
    pub properties: PropertyList,
}
#[automatically_derived]
impl ::core::clone::Clone for RuleSet {
    #[inline]
    fn clone(&self) -> RuleSet {
        RuleSet {
            selectors: ::core::clone::Clone::clone(&self.selectors),
            properties: ::core::clone::Clone::clone(&self.properties),
        }
    }
}
pub struct Stylesheet(pub Vec<RuleSet>);
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{0:?}", self))
    }
}
impl std::error::Error for Error {}
impl<'a> TryFrom<Vec<pest::iterators::Pair<'a, Rule>>> for PropertyList {
    type Error = Error;
    fn try_from(
        values: Vec<pest::iterators::Pair<'a, Rule>>,
    ) -> Result<Self, Self::Error> {
        ::core::panicking::panic("not yet implemented")
    }
}
impl<'a> TryFrom<pest::iterators::Pair<'a, Rule>> for Selector {
    type Error = Error;
    fn try_from(value: pest::iterators::Pair<'a, Rule>) -> Result<Self, Self::Error> {
        match (&value.as_rule(), &Rule::Selector) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        ::core::panicking::panic("not yet implemented")
    }
}
