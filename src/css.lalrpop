
// use crate::ast::{Unit, Combinator, Property, PropertySet, Selector};
use crate::ast::*;

grammar;

pub Css: Vec<PropertySet> =
    <first:PropertySet> <rest:PropertySet*> => vec![first].into_iter().chain(rest.into_iter()).collect();

pub PropertySet: PropertySet =
    <selectors:SelectorList> "{" <properties:PropertyList> "}" => PropertySet::new(selectors, properties);

pub SelectorList: Vec<Selector> = {
    <first:Selector> "," <rest:SelectorList> => vec![first].into_iter().chain(rest.into_iter()).collect(),
    <sel:Selector> => vec![sel],
}

pub Selector: Selector = {
    SimpleSelector => Selector::Simple(<>),
    CompoundSelector => Selector::Compound(<>),
    ComplexSelector => Selector::Complex(<>),
};

pub ComplexSelector: ComplexSelector = {
    <sel:CompoundSelector> <first:Combination> <rest:Combination*> => (sel, vec![first].into_iter().chain(rest.into_iter()).collect()),
};

pub Combination: Combinator = {
    "+" <sel:CompoundSelector> => Combinator::NextSibling(sel),
    ">" <sel:CompoundSelector> => Combinator::Child(sel),
    "||" <sel:CompoundSelector> => Combinator::Column(sel),
    "~" <sel:CompoundSelector> => Combinator::SubsequentSibling(sel),
    " " <sel:CompoundSelector> => Combinator::Descendent(sel),
    "|" <sel:CompoundSelector> => Combinator::Namespace(sel),
}

pub CompoundSelector: CompoundSelector = {
    // <first:SimpleSelector> <rest:SimpleSelector*> => vec![first].into_iter().chain(rest.into_iter()).collect()
}

// TODO: Implement AttributeSelector, PseudoclassSelector, PseudoelementSelector
pub SimpleSelector: SimpleSelector = {
    BasicSelector => SimpleSelector::Basic(<>),
    // AttributeSelector => SimpleSelector::Attribute(<>),
    // PseudoclassSelector => SimpleSelector::Pseudoclass(<>),
    // PseudoelementSelector => SimpleSelector::Pseudoelement(<>),
}

pub BasicSelector: BasicSelector = {
    r"[\w&&[^\d]]\w*"   => BasicSelector::Type(<>.to_string()),
    r"\.[\w&&[^\d]]\w*" => BasicSelector::Class(<>.to_string()),
    r"#[\w&&[^\d]]\w*"  => BasicSelector::Id(<>.to_string()),
    r"\*"               => BasicSelector::Universal,
}

pub PropertyList: Vec<Property> = 
    <first:Property> <rest:Property*> => vec![first].into_iter().chain(rest.into_iter()).collect();

pub Property: Property = {
    <ident:r"[\w&&[^\d]]\w*"> ":" <value:r"\w+"> ";" => (ident, Some((value.to_string(), value.into()))),
    <ident:r"[\w&&[^\d]]\w*"> ";" => (ident.to_string(), None),
};

pub Identifier: String = r"[\w&&[^\d]]\w*" => String::from(<>);
// pub Number: f32 = r"\d*\.?\d+" => <>.parse::<f32>().unwrap();


